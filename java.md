- [一、基础专题](#一基础专题)
  - [1. Java基础篇](#1-java基础篇)
    - [反射机制详解](#反射机制详解)
      - [什么是JAVA反射机制](#什么是java反射机制)
      - [反射提供了哪些功能](#反射提供了哪些功能)
      - [反射应用场景](#反射应用场景)
      - [反射原理](#反射原理)
      - [反射机制的优缺点](#反射机制的优缺点)
  - [2. 集合篇](#2-集合篇)
  - [3. JVM篇](#3-jvm篇)
  - [4. 设计模式篇](#4-设计模式篇)
  - [5. 并发编程篇](#5-并发编程篇)
  - [6. 网络基础篇](#6-网络基础篇)
  - [7. 网络IO篇](#7-网络io篇)
  - [8.操作系统篇](#8操作系统篇)
    - [8.1 Linux常用命令](#81-linux常用命令)
    - [8.2 shell编程](#82-shell编程)
- [二、开发基础框架专题](#二开发基础框架专题)
  - [1. 框架源码篇](#1-框架源码篇)
    - [1.1 Mybatis框架](#11-mybatis框架)
    - [1.2 Spring框架](#12-spring框架)
    - [1.3 SpringBoot框架](#13-springboot框架)
  - [2. 开发常用类库篇](#2-开发常用类库篇)
  - [3. 开发单元测试篇](#3-开发单元测试篇)
  - [4. 开发网络安全篇](#4-开发网络安全篇)
- [三、数据库专题](#三数据库专题)
  - [1. MYSQL](#1-mysql)
  - [2. NoSQL](#2-nosql)
    - [2.1 Redis](#21-redis)
    - [2.2 Memcached](#22-memcached)
    - [2.3 Elasticsearch](#23-elasticsearch)
    - [2.4 MongoDB](#24-mongodb)
- [四、分布式专题](#四分布式专题)
  - [1. 分布架构设计与演进](#1-分布架构设计与演进)
  - [2. 分布式通信框架](#2-分布式通信框架)
  - [3. 分布式协调服务](#3-分布式协调服务)
  - [4. 分布式服务治理](#4-分布式服务治理)
  - [5. 分布式消息](#5-分布式消息)
    - [RocketMQ](#rocketmq)
      - [Producer怎么发送消息](#producer怎么发送消息)
      - [消息存储](#消息存储)
      - [Consumer怎么消费消息](#consumer怎么消费消息)
      - [事务消息](#事务消息)
      - [**消息重复**](#消息重复)
      - [顺序消费](#顺序消费)
      - [负载均衡](#负载均衡)
  - [6. 分布式缓存](#6-分布式缓存)
- [五、微服务专题](#五微服务专题)
- [六、运维专题](#六运维专题)
- [七、搜索专题](#七搜索专题)
- [八、大数据专题](#八大数据专题)
- [九、系统架构设计专题](#九系统架构设计专题)
- [十、数据结构与算法专题](#十数据结构与算法专题)
- [十一、部署与工具专题](#十一部署与工具专题)
- [十二、人工智能专题](#十二人工智能专题)
- [消息队列篇](#消息队列篇)

# 一、基础专题

> 参考：https://github.com/idaSmilence/javaP7/blob/master/JAVA.md#%E4%B8%80%E5%9F%BA%E7%A1%80%E7%AF%87

## 1. Java基础篇

### 反射机制详解

**目标**

1. 什么是Java反射机制？
2. 反射机制提供了哪些功能？
3. 反射机制应用场景
4. 反射机制的原理

#### 什么是JAVA反射机制

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。

#### 反射提供了哪些功能

- 在运行时判定任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判定任意一个类所具有的成员变量和方法
- 在运行时调用任意一个对象的方法
- 生产动态代理

#### 反射应用场景

- **逆向代码**-例如反编译
- **开发通用框架** - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。
- **动态代理** - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态处理方式。这时，就需要反射技术来实现
  - JDK动态代理： spring默认动态代理，需要实现接口
  - CGLIB：通过asm框架序列化字节流，可配置，性能查
- **自定义注解** - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据主键标记去调用注解解释器，执行行为。
- **动态生成类的框架** -  例如 Gson
- **BeanUtil相关工具** - 例如 MapStruct

#### 反射原理

反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法、变量、构造函数等映射成响应的Method、Field、Constructor等类对象

以上只是核心知识点梳理，详细原理请看[反射机制详情](javabase/reflect.md)

#### 反射机制的优缺点

**优点：**

运行期类型的判断（RTTI，Run-Time Type Identification），动态类加载，动态代理使用反射。

**缺点：**

性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的Java代码要慢很多

**总结：**

Java的反射机制在平时的业务开发过程中使用频率较低，但是在一些基础框架的搭建上应用比较广泛，例如Spring框架中就使用了许多反射。



## 2. 集合篇

## 3. JVM篇

## 4. 设计模式篇

## 5. 并发编程篇

## 6. 网络基础篇

## 7. 网络IO篇

## 8.操作系统篇

### 8.1 Linux常用命令

### 8.2 shell编程



# 二、开发基础框架专题

## 1. 框架源码篇

### 1.1 Mybatis框架

### 1.2 Spring框架

### 1.3 SpringBoot框架



## 2. 开发常用类库篇

## 3. 开发单元测试篇

## 4. 开发网络安全篇

# 三、数据库专题

## 1. MYSQL

## 2. NoSQL

### 2.1 Redis

### 2.2 Memcached

### 2.3 Elasticsearch

### 2.4 MongoDB

# 四、分布式专题

## 1. 分布架构设计与演进

## 2. 分布式通信框架

## 3. 分布式协调服务

## 4. 分布式服务治理

## 5. 分布式消息

消息队列作为高并发系统的核心组件之一，能够帮助业务系统解构提升开发效率和稳定性。

作用：

- 削峰填谷 （主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题）
- 异步处理，提升性能 （当存在一对多调用时，可以通过消息通知相关系统）
- 蓄流压测（线上有些链路不好压测，可以通过堆积线上一定量消息再开放来压测）

**MQ选型**

**中小型公司**，技术实力较为一般，技术挑战不是特别高，用 **RabbitMQ** （开源、社区活跃）是不错的选择；**大型公司**，基础架构研发实力较强，用 **RocketMQ**（Java二次开发） 是很好的选择。

如果是**大数据领域**的实时计算、日志采集等场景，用 **Kafka** 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。

|                        | RocketMQ                                                     | RabbitMQ                                                     | Kafka                                                        |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 设计定位               | 非日志的可靠消息传输。例如：订单，交易，充值，流计算，消息推送，binlog分发等 |                                                              | 系统间的数据流管道，实时数据处理。例如常规消息系统，网络活性跟踪，监控数据收集，处理等 |
| 单机吞吐量             | 10W                                                          | 1w                                                           | 10w                                                          |
| 消息延迟               | 毫秒                                                         | 微秒                                                         | 毫秒                                                         |
| 消息丢失               | 参数优化后可以0丢失                                          | 可能性很低                                                   | 参数优化后可以0丢失                                          |
| 消息模式               | 推拉                                                         | 推拉                                                         | 拉取                                                         |
| 主题数量对吞吐量的影响 | 几百以上主题会对吞吐量有较小的影响                           | \                                                            | 几十上百个主题会极大影响吞吐量                               |
| 可用性                 | 很高 （主从）                                                | 高（主从）                                                   | 很高（分布式）                                               |
| 优点                   | 1. 在高吞吐、低延迟、高可用上有很好表现。消息堆积时，性能也很好<br>2.api设计更加适合业务处理的场景<br>3.支持多种消费方式<br>4.支持broker消息过滤<br>5.支持事务<br>6.支持顺序消费<br> | 1.轻量级，快速部署方便<br>2.支持灵活的路由配置。RabbitMQ中，在生产者和队列之间有一个交换器模块。根据配置的路由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。<br>3.客户端支持大多数编程语言，支持AMQP协议 | 1. 在高吞吐、低延迟、高可用、集群热扩展、容错上有非常好的表现<br/>2. producer端提供缓存、压缩功能，可节省性能，提高效率<br/>3. 提供顺序消费能力<br/>4.提供多种客户端语言<br/>5.生态完善，在大数据处理方面有大量配套设施 |
| 缺点                   |                                                              | 1.如果有大量消息堆积在队列中，性能会急剧下降<br>2. 每秒处理几万到几十万的消息<br>3.Erlang语言开发，功能扩展和二次开发代价高 | 1. 消费集群数目收到分区数目的限制<br>2.单机topic多时，性能会明显降低<br/>3.不支持事务 |



### RocketMQ

**目标**

- 了解rocketMQ架构
- 了解Producer如何发送消息
- 消息怎么存储
- Consumer怎么消费消息
- 了解RocketMQ关键机制的设计原理
  - 消息存储
  - 通信机制
  - 消息过滤
  - 负载均衡
  - 事务消息
  - 顺序消费
  - 消息重复

> 关键机制的设计原理参考官方文档：https://github.com/apache/rocketmq/blob/master/docs/cn/design.md



![image-20211011224803085](../hexo/blog/source/images/image-20211011224803085.png)

#### Producer怎么发送消息

Producer与Name Server集群中某个节点（随机选择）建立长连接，定期获取topic路由信息。Producer轮询某topic下所有队列的方式来实现发送方的负载均衡。如图

<img src="../hexo/blog/source/images/image-20211011230950804.png" alt="image-20211011230950804" style="zoom:50%;" />

#### 消息存储

是由Comsume Queue和Commit Log配置完成的

#### Consumer怎么消费消息

有两种模式

**pull模式**：consumer端每隔一段时间主动像broker发送拉消息请求

**push模式**：本质也是拉模式，只是对pull模式的一种封装，与broker建立长连接，成功拉取到一批消息后，不会断开连接，而是继续向服务端拉取消息，如果broker收到pull消息后，消息队列中没有数据，broker会阻塞该请求，直到有数据或者超时才返回。

Consumer实现负责均衡：

<img src="../hexo/blog/source/images/image-20211011233251054.png" alt="image-20211011233251054" style="zoom:50%;" />

consumer端会通过RebalanceService线程，10s做一次基于Topic下的所有队列负载：

1. 遍历consumer下所有的topic， 然后根据topic订阅所有的消息
2. 获取同一个topic和consume group下所有的consumer
3. 然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费配置等。

如上图所示，topicTestA有8个队列，consume group中有两个consumer， 采用平均分配策略，各消费4个消费队列

#### 事务消息

RocketMQ在4.3.0版本开始支持分布式事务消息。主要通过2PC思想来实现提交事务消息，同时增加了补偿逻辑来回查二阶段超时或者失败的消息

![image-20211012084050102](../hexo/blog/source/images/image-20211012084050102.png)

主要分为两个流程：正常事务操作、事务消息的补偿流程

- 正常事务流程：

  - 发送half消息，会拿到消息的地址，（此时half消息对业务不可见）
  - 执行本地事务
  - 根据本地事务状态执行commit或者rollback （commit操作生成对消费者可见的消息索引）

- 补偿逻辑流程：（解决消息commit 或者 rollback发生超时或者失败的情况）

  - 对没有 commit/ rollback的事务消息，从服务端发起一次 “回查”
  - Producer收到回查消息，检查回查消息对应的本地事务状态，重新commit/rollback

  注意：信息事务回查，默认是15次，超过15次，rocketmq默认回滚消息。

除了MQ的事务处理方式，可以通过增加本地事件表的方式来实现

![image-20211010221456051](../hexo/blog/source/images/image-20211010221456051.png)

#### **消息重复**

RocketMQ没有解决消息重复问题，因为会影响系统的吞吐量和高可用。

造成消息重复的根本原因是：网络不可达

那么问题就变成了：如果消费端收到两条一样的消息，该怎么处理？

答：保证在消息重发的时候，消费者不会重复处理。即使在**消费者收到重复消息的时候，重复处理**，也

要**保证最终结果的一致性**。所谓幂等性。

**如何实现？**

每条数据都有唯一的消息ID，利用一张日志表记录已经成功处理的消息ID，如果新到的消息ID在日志表中，则消费端就不处理这条消息。

#### 顺序消费

- 全局顺序：对指定的一个topic，所有消息都严格按照先入先出的顺序发布和消费。会影响消息系统的吞吐量。适用场景：性能要求不高

  ```markdown
  执行严格全局顺序
  保证 Producer -> MQserver -> consumer是一对一关系
  
  注意 这样的设计⽅案问题：
  1.并⾏度会成为消息系统的瓶颈（吞吐量不够）
  2.产⽣更多的异常处理。⽐如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的
  精 ⼒来解决阻塞的问题。
  ```

  

- 分区顺序

  - 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区，保证在同一分区内是顺序消费的。适用场景：性能要求高

  ```markdown
  1. producer通过轮询topic的所有队列的方式来确定消息被发送到哪个队列 （负载均衡策略）
  2. 获取到路由信息后，会根据MessageQueueSelector实现的算法来选择⼀个队列，保证同一个OrderID获取到的肯定是同一个队列
  ```

#### 负载均衡

RocketMQ的负载均衡都是在client端完成的。

- Producer端：通过轮序topic获取所有队列，在根据MessageQueueSelector实现的算法来选择一个队列
- Consumer端：对于同一topic下的所有队列，Consumer group下的所有Consumer，根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费配置等。

## 6. 分布式缓存

# 五、微服务专题

# 六、运维专题

# 七、搜索专题

# 八、大数据专题

# 九、系统架构设计专题

# 十、数据结构与算法专题

# 十一、部署与工具专题

# 十二、人工智能专题

# 消息队列篇

paslur

